---
title: Boyce-Codd Normal Form (BCNF)
slug: boyce-codd-normal-form
---

import Section from "@mdx/Section.astro";
import CodeTabs from '@mdx/CodeTabs.astro';
import CodeTab from '@mdx/CodeTab.astro';
import Callout from '@mdx/Callout.astro';

Boyce-Codd Normal Form (BCNF) is a stricter form of normalization than Third Normal Form (3NF). While 3NF focuses on the relationship between non-prime attributes and candidate keys, BCNF goes a step further by addressing potential redundancies even when 3NF is achieved. The goal is to eliminate all redundancy that can be detected through functional dependencies.

In practice, you barely see tables in 3NF that violate BCNF. However, it's important to understand the concept of BCNF.

## Key concepts

1. A `Candidate key` is a minimal set of attributes that can uniquely identify each row in a table. There can be multiple candidate keys in a table.
2. A `Non-prime` attribute is a column that isn't part of any candidate key.
3. A `Super key` is a candidate key or a superset of a candidate key.
4. A `Functional dependency` is a relationship between two sets of attributes in a table, where the value of one set uniquely determines the value of another.
5. A functional dependency `X -> Y` in a relation `R` is considered trivial if the set of attributes `Y` is a subset of (or equal to) the set of attributes `X`.

## The BCNF Rule

To achieve BCNF, table should already be in 3NF and must satisfy the following condition:

For every non-trivial functional dependency X -> Y, the determinant (X) must be a super key. In simpler terms, the left-hand side of any functional dependency must uniquely determine the entire row in the table.

## Example

We have a table `classroom_assignment` with the following schema:

<CodeTabs items={["schema.ts", "schema.sql", "schema.txt"]}>
  <CodeTab>
    ```ts
    import { pgTable, primaryKey, varchar } from "drizzle-orm/pg-core";   

    export const classroomAssignment = pgTable("classroom_assignment", {
      roomNumber: varchar("room_number", { length: 10 }).notNull(),
      professor: varchar("professor", { length: 100 }).notNull(),
      course: varchar("course", { length: 100 }).notNull(),
    }, (t) => [
      primaryKey({ columns: [t.roomNumber, t.course] }),
    ]);
   ```
  </CodeTab>
  <CodeTab>
    ```sql
    CREATE TABLE "classroom_assignment" (
    	"room_number" varchar(10) NOT NULL,
    	"professor" varchar(100) NOT NULL,
    	"course" varchar(100) NOT NULL,
    	CONSTRAINT "classroom_assignment_room_number_course_pk" PRIMARY KEY("room_number","course")
    );
    ```
  </CodeTab>
  <CodeTab>
  ```plaintext
    +--------------+----------------+-----------+
    | classroom_assignment                      |
    +--------------+----------------+-----------+
    | room_number  | professor      | course    |
    +--------------+----------------+-----------+
    | A101         | Dr. Smith      | CS101     |
    | B202         | Dr. Jones      | CS101     |
    | A101         | Dr. Smith      | CS102     |
    | C303         | Dr. Brown      | CS103     |
    +--------------+----------------+-----------+
  ```
  </CodeTab>
</CodeTabs>

1. Each professor is assigned exactly one room and teaches all their assigned courses from that specific room.
2. A professor may teach multiple courses, and a course may be taught by multiple professors.
3. A specific course offering in a particular room is taught by exactly one professor.

### Functional Dependencies

1. `room_number, course -> professor`
2. `professor, course -> room_number`
3. `professor -> room_number`

### Candidate keys

The table has two candidate keys: `room_number, course` and `professor, course`. Each of these can uniquely determine all attributes in the table.

### 3NF Analysis

Since every attribute in this table is part of at least one candidate key, there are no non-prime attributes. This means no transitive dependencies exist, so the table is in 3NF.

### BCNF Analysis

The relation is not in BCNF because of this functional dependency:

`professor -> room_number`

The left-hand side (`professor`) is not a super key. Both `room_number` and `professor` are prime attributes because they are part of candidate keys. This dependency violates the BCNF rule.

This leads to:
1. Information duplication.
2. Update anomalies. If a professor's assigned room changes, we must update multiple rows to reflect the change.
3. Deletion anomalies. If all courses taught by a professor are removed, we lose information about the professor's room assignment.

### Solution

We need to split the table to eliminate the problematic dependency. We create two tables:

<CodeTabs items={["schema.ts", "schema.sql", "schema.txt"]}>
  <CodeTab>
    ```ts
    import { pgTable, primaryKey, varchar } from "drizzle-orm/pg-core";

    export const professorRoom = pgTable("professor_room", {
      professor: varchar("professor", { length: 100 }).notNull().primaryKey(),
      roomNumber: varchar("room_number", { length: 10 }).notNull(),
    });

    export const courseProfessor = pgTable("course_professor", {
      course: varchar("course", { length: 100 }).notNull(),
      professor: varchar("professor", { length: 100 }).notNull(),
    }, (t) => [
      primaryKey({ columns: [t.course, t.professor] }),
    ]);
    ```
  </CodeTab>
  <CodeTab>
  ```sql
    CREATE TABLE "course_professor" (
    	"course" varchar(100) NOT NULL,
    	"professor" varchar(100) NOT NULL,
    	CONSTRAINT "course_professor_course_professor_pk" PRIMARY KEY("course","professor")
    );

    CREATE TABLE "professor_room" (
    	"professor" varchar(100) PRIMARY KEY NOT NULL,
    	"room_number" varchar(10) NOT NULL
    );
  ```
  </CodeTab>
  <CodeTab>
  ```plaintext
    +--------------+---------------+   +--------------+---------------+   
    | professor_room               |   | course_professor             |
    +--------------+---------------+   +--------------+---------------+
    | professor    |  room_number  |   | course       | professor     |
    +--------------+---------------+   +--------------+---------------+
    | Dr. Smith    | A101          |   | CS101        | Dr. Smith     |
    | Dr. Jones    | B202          |   | CS101        | Dr. Jones     |
    | Dr. Brown    | C303          |   | CS102        | Dr. Smith     |
    +--------------+---------------+   | CS103        | Dr. Brown     |
                                       +--------------+---------------+
  ```
  </CodeTab>
</CodeTabs>

<Callout type="warning">
You should also add a foreign key constraint to the `course_professor` table to reference the `professor` in the `professor_room` table.
</Callout>

We have achieved BCNF by splitting the table into two tables: `professor_room` and `course_professor`. Now, the tables are free from functional dependencies that violate BCNF.
