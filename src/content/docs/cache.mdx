import Callout from '@mdx/Callout.astro';

# Cache

Drizzle sends every query straight to your database by default. There are no hidden actions, no automatic caching 
or invalidation - you'll always see exactly what runs. If you want caching, you must opt in.

By default, Drizzle uses a `explicit` caching strategy (i.e. `global: false`), so nothing is ever cached unless you ask. 
This prevents surprises or hidden performance traps in your application. 
Alternatively, you can flip on `all` caching (`global: true`) so that every select will look in cache first.



## Upstash Integration

Drizzle ships a built-in Upstash cache helper. It supports everything except keepTtl, pxat, exat, and raw px (use ex instead).

```ts
import { upstashCache } from 'drizzle-orm/cache/upstash';
import { drizzle } from 'drizzle-orm/...';

const db = drizzle(process.env.DB_URL!, { cache: upstashCache() })
```

Define cache credentials, but no cache will be used globally for all queries
```ts
import { upstashCache } from 'drizzle-orm/cache/upstash';
import { drizzle } from 'drizzle-orm/...';

const db = drizzle(process.env.DB_URL!, { 
    cache: upstashCache({ url: '', token: '' }) 
})
```

Define cache credentials, and the cache will be used globally for all queries
```ts
import { upstashCache } from 'drizzle-orm/cache/upstash';
import { drizzle } from 'drizzle-orm/...';

const db = drizzle(process.env.DB_URL!, { 
    cache: upstashCache({ url: '', token: '', global: true }) 
})
```

Define cache credentials with custom config values to be used for all queries, unless overridden
```ts
import { upstashCache } from 'drizzle-orm/cache/upstash';
import { drizzle } from 'drizzle-orm/...';

const db = drizzle(process.env.DB_URL!, { 
    cache: upstashCache({ url: '', token: '', global: true, config: {} }) 
})
```

Upstash cache will only use 2 of all cache options:

`ex` - to define and expire time for a query

`hexOptions` - define how hex expire will work
<Callout title='hex options'>
`NX` -- For each specified field, set expiration only when the field has no expiration.

`XX` -- For each specified field, set expiration only when the field has an existing expiration.

`GT` -- For each specified field, set expiration only when the new expiration is greater than current one.

`LT` -- For each specified field, set expiration only when the new expiration is less than current one.
</Callout>

```ts
export type CacheConfig = {
    /**
     * expire time, in seconds (a positive integer)
     */
    ex?: number;
    /**
     * Set an expiration (TTL or time to live) on one or more fields of a given hash key.
     * Used for HEXPIRE command
     */
    hexOptions?: 'NX' | 'nx' | 'XX' | 'xx' | 'GT' | 'gt' | 'LT' | 'lt';
};
```

## Cache usage examples

Once you've provided all the necessary instructions to the Drizzle database instance, you can now use the cache with Drizzle

**Case 1: Drizzle with `global: false` option**

```ts
import { upstashCache } from 'drizzle-orm/cache/upstash';
import { drizzle } from 'drizzle-orm/...';

const db = drizzle(process.env.DB_URL!, { cache: upstashCache({ url: '', token: '' }) })
```

In this case, the current query won't use the cache

```ts
const res = await db.select().from(users)

// However, any mutate operation will trigger the onMutate function in the cache
// and attempt to invalidate queries that used the tables involved in this mutation query.
await db.insert(users).value({ email: 'cacheman@upstash.com' })
```

If you want the query to actually use the cache, you need to call `.$withCache()`

```ts
const res = await db.select().from(users).$withCache()
```

`.$withCache` has a set of options you can use to manage and configure this specific query strategy

```ts
// rewrite the global config options for this specific query
.$withCache({ config: {} })

// give a query custom cache key instead of hashing query+params under the hood
.$withCache({ tag: 'custom_key' })

// disable auto-invalidation for this query, if you are fine with eventual consistency for this specific query(Eventual consistency explained below)
.$withCache({ autoInvalidate: false })
```

<Callout>
**Eventual consistency example**

Imagine you cache a select on `usersTable` with a 3-second TTL:

``` ts
const recent = await db
  .select().from(usersTable)
  .$withCache({ config: { ex: 3 }, autoInvalidate: false });
```

If someone else runs `db.insert(usersTable)...` immediately, that mutation won`t clear your cache.
You`ll keep seeing the old data for up to 3 seconds, which is classic eventual consistency.
</Callout>

**Case 2: Drizzle with `global: true` option**

```ts
import { upstashCache } from 'drizzle-orm/cache/upstash';
import { drizzle } from 'drizzle-orm/...';

const db = drizzle(process.env.DB_URL!, { cache: upstashCache({ url: '', token: '', global: true }) })
```

In this case, the current query will use the cache

```ts
const res = await db.select().from(users)
```

If you want the query to disable cache for some specific query, you need to call `.$withCache(false)`

```ts
// cache is disabled for this query
const res = await db.select().from(users).$withCache(false)
```

You can also use cache instance from a `db` to force invalidate specific tables or tags you've defined previously

```ts
// Invalidate all queries that use the `users` table. You can do this with the Drizzle instance.
await db.$cache?.invalidate({ tables: users });
// or
await db.$cache?.invalidate({ tables: [users, posts] });

// Invalidate all queries that use the `usersTable`. You can do this by using just the table name.
await db.$cache?.invalidate({ tables: 'usersTable' });
// or
await db.$cache?.invalidate({ tables: ['usersTable' , 'postsTable' ] });

// You can also invalidate custom tags defined in any previously executed select queries.
await db.$cache?.invalidate({ tags: 'custom_key' });
// or
await db.$cache?.invalidate({ tags: ['custom_key', 'custom_key1'] });
```

## Custom cache

This example shows how to plug in a custom `cache` in Drizzle: you provide functions to fetch data from cache, 
store results back into cache, and invalidate entries whenever a mutation runs.

```ts
const db = drizzle(process.env.DB_URL!, { cache: new TestGlobalCache() })
```

```ts
import Keyv from 'keyv';

export class TestGlobalCache extends Cache {
  private globalTtl: number = 1000;
  // This object will be used to store which query keys were used
  // for a specific table, so we can later use it for invalidation.
  private usedTablesPerKey: Record<string, string[]> = {};

  constructor(private kv: Keyv = new Keyv()) {
    super();
  }

  // For the strategy, we have two options:
  // - 'explicit': The cache is used only when .$withCache() is added to a query.
  // - 'all': All queries are cached globally.
  // The default behavior is 'explicit'.
  override strategy(): 'explicit' | 'all' {
    return 'all';
  }

  // This function accepts query and parameters that cached into key param,
  // allowing you to retrieve response values for this query from the cache.
  override async get(key: string): Promise<any[] | undefined> {
    const res = await this.kv.get(key) ?? undefined;
    return res;
  }

  // This function accepts several options to define how cached data will be stored:
  // - 'key': A hashed query and parameters.
  // - 'response': An array of values returned by Drizzle from the database.
  // - 'tables': An array of tables involved in the select queries. This information is needed for cache invalidation.
  //
  // For example, if a query uses the "users" and "posts" tables, you can store this information. Later, when the app executes
  // any mutation statements on these tables, you can remove the corresponding key from the cache. 
  // If you're okay with eventual consistency for your queries, you can skip this option.
  override async put(key: string, response: any, tables: string[], config?: CacheConfig): Promise<void> {
    await this.kv.set(key, response, config ? config.ex : this.globalTtl);
    for (const table of tables) {
      const keys = this.usedTablesPerKey[table];
      if (keys === undefined) {
        this.usedTablesPerKey[table] = [key];
      } else {
        keys.push(key);
      }
    }
  }

  // This function is called when insert, update, or delete statements are executed. 
  // You can either skip this step or invalidate queries that used the affected tables.
  //
  // The function receives an object with two keys:
  // - 'tags': Used for queries labeled with a specific tag, allowing you to invalidate by that tag.
  // - 'tables': The actual tables affected by the insert, update, or delete statements, 
  //   helping you track which tables have changed since the last cache update.
  override async onMutate(params: { tags: string | string[], tables: string | string[] | Table<any> | Table<any>[]}): Promise<void> {
    const tagsArray = params.tags ? Array.isArray(params.tags) ? params.tags : [params.tags] : [];
    const tablesArray = params.tables ? Array.isArray(params.tables) ? params.tables : [params.tables] : [];

    const keysToDelete = new Set<string>();

    for (const table of tablesArray) {
      const tableName = is(table, Table) ? getTableName(table) : table as string;
      const keys = this.usedTablesPerKey[tableName] ?? [];
      for (const key of keys) keysToDelete.add(key);
    }

    if (keysToDelete.size > 0 || tagsArray.length > 0) {
      for (const tag of tagsArray) {
        await this.kv.delete(tag);
      }

      for (const key of keysToDelete) {
        await this.kv.delete(key);
        for (const table of tablesArray) {
          const tableName = is(table, Table) ? getTableName(table) : table as string;
          this.usedTablesPerKey[tableName] = [];
        }
      }
    }
  }
}
```